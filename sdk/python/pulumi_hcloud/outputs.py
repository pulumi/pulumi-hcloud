# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'FirewallApplyTo',
    'FirewallRule',
    'LoadBalancerAlgorithm',
    'LoadBalancerServiceHealthCheck',
    'LoadBalancerServiceHealthCheckHttp',
    'LoadBalancerServiceHttp',
    'LoadBalancerTarget',
    'ServerNetwork',
    'ServerPublicNet',
    'GetCertificatesCertificateResult',
    'GetDatacentersDatacenterResult',
    'GetFirewallApplyToResult',
    'GetFirewallRuleResult',
    'GetFirewallsFirewallResult',
    'GetFirewallsFirewallApplyToResult',
    'GetFirewallsFirewallRuleResult',
    'GetFloatingIpsFloatingIpResult',
    'GetImagesImageResult',
    'GetLoadBalancerAlgorithmResult',
    'GetLoadBalancerServiceResult',
    'GetLoadBalancerServiceHealthCheckResult',
    'GetLoadBalancerServiceHealthCheckHttpResult',
    'GetLoadBalancerServiceHttpResult',
    'GetLoadBalancerTargetResult',
    'GetLoadBalancersLoadBalancerResult',
    'GetLoadBalancersLoadBalancerAlgorithmResult',
    'GetLoadBalancersLoadBalancerServiceResult',
    'GetLoadBalancersLoadBalancerServiceHealthCheckResult',
    'GetLoadBalancersLoadBalancerServiceHealthCheckHttpResult',
    'GetLoadBalancersLoadBalancerServiceHttpResult',
    'GetLoadBalancersLoadBalancerTargetResult',
    'GetLocationsLocationResult',
    'GetNetworksNetworkResult',
    'GetPlacementGroupsPlacementGroupResult',
    'GetPrimaryIpsPrimaryIpResult',
    'GetServerTypesServerTypeResult',
    'GetServersServerResult',
    'GetSshKeysSshKeyResult',
    'GetVolumesVolumeResult',
]

@pulumi.output_type
class FirewallApplyTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelector":
            suggest = "label_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallApplyTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallApplyTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallApplyTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selector: Optional[str] = None,
                 server: Optional[int] = None):
        """
        :param str label_selector: Label Selector to select servers the firewall should be applied to (only one
               of `server` and `label_selector`can be applied in one block)
        :param int server: ID of the server you want to apply the firewall to (only one of `server`
               and `label_selector`can be applied in one block)
        """
        FirewallApplyTo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_selector=label_selector,
            server=server,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_selector: Optional[str] = None,
             server: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if label_selector is None and 'labelSelector' in kwargs:
            label_selector = kwargs['labelSelector']

        if label_selector is not None:
            _setter("label_selector", label_selector)
        if server is not None:
            _setter("server", server)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[str]:
        """
        Label Selector to select servers the firewall should be applied to (only one
        of `server` and `label_selector`can be applied in one block)
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def server(self) -> Optional[int]:
        """
        ID of the server you want to apply the firewall to (only one of `server`
        and `label_selector`can be applied in one block)
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class FirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationIps":
            suggest = "destination_ips"
        elif key == "sourceIps":
            suggest = "source_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: str,
                 protocol: str,
                 description: Optional[str] = None,
                 destination_ips: Optional[Sequence[str]] = None,
                 port: Optional[str] = None,
                 source_ips: Optional[Sequence[str]] = None):
        """
        :param str direction: Direction of the Firewall Rule. `in`
        :param str protocol: Protocol of the Firewall Rule. `tcp`, `icmp`, `udp`, `gre`, `esp`
        :param str description: Description of the firewall rule
        :param Sequence[str] destination_ips: (Required, List) List of CIDRs that are allowed within this Firewall Rule (when `direction`
               is `out`)
        :param str port: Port of the Firewall Rule. Required when `protocol` is `tcp` or `udp`. You can use `any`
               to allow all ports for the specific protocol. Port ranges are also possible: `80-85` allows all ports between 80 and
               85.
        :param Sequence[str] source_ips: List of CIDRs that are allowed within this Firewall Rule
        """
        FirewallRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            protocol=protocol,
            description=description,
            destination_ips=destination_ips,
            port=port,
            source_ips=source_ips,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: Optional[str] = None,
             protocol: Optional[str] = None,
             description: Optional[str] = None,
             destination_ips: Optional[Sequence[str]] = None,
             port: Optional[str] = None,
             source_ips: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if destination_ips is None and 'destinationIps' in kwargs:
            destination_ips = kwargs['destinationIps']
        if source_ips is None and 'sourceIps' in kwargs:
            source_ips = kwargs['sourceIps']

        _setter("direction", direction)
        _setter("protocol", protocol)
        if description is not None:
            _setter("description", description)
        if destination_ips is not None:
            _setter("destination_ips", destination_ips)
        if port is not None:
            _setter("port", port)
        if source_ips is not None:
            _setter("source_ips", source_ips)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Direction of the Firewall Rule. `in`
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol of the Firewall Rule. `tcp`, `icmp`, `udp`, `gre`, `esp`
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the firewall rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationIps")
    def destination_ips(self) -> Optional[Sequence[str]]:
        """
        (Required, List) List of CIDRs that are allowed within this Firewall Rule (when `direction`
        is `out`)
        """
        return pulumi.get(self, "destination_ips")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port of the Firewall Rule. Required when `protocol` is `tcp` or `udp`. You can use `any`
        to allow all ports for the specific protocol. Port ranges are also possible: `80-85` allows all ports between 80 and
        85.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Optional[Sequence[str]]:
        """
        List of CIDRs that are allowed within this Firewall Rule
        """
        return pulumi.get(self, "source_ips")


@pulumi.output_type
class LoadBalancerAlgorithm(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        :param str type: Type of the Load Balancer Algorithm. `round_robin` or `least_connections`
        """
        LoadBalancerAlgorithm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the Load Balancer Algorithm. `round_robin` or `least_connections`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LoadBalancerServiceHealthCheck(dict):
    def __init__(__self__, *,
                 interval: int,
                 port: int,
                 protocol: str,
                 timeout: int,
                 http: Optional['outputs.LoadBalancerServiceHealthCheckHttp'] = None,
                 retries: Optional[int] = None):
        """
        :param int interval: Interval how often the health check will be performed, in seconds.
        :param int port: Port the health check tries to connect to, required if protocol is `tcp`. Can be everything between `1` and `65535`. Must be unique per Load Balancer.
        :param str protocol: Protocol the health check uses. `http` or `tcp`
        :param int timeout: Timeout when a health check try will be canceled if there is no response, in seconds.
        :param 'LoadBalancerServiceHealthCheckHttpArgs' http: HTTP configuration. Required if `protocol` is `http`.
        :param int retries: Number of tries a health check will be performed until a target will be listed as `unhealthy`.
        """
        LoadBalancerServiceHealthCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interval=interval,
            port=port,
            protocol=protocol,
            timeout=timeout,
            http=http,
            retries=retries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interval: Optional[int] = None,
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             timeout: Optional[int] = None,
             http: Optional['outputs.LoadBalancerServiceHealthCheckHttp'] = None,
             retries: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if interval is None:
            raise TypeError("Missing 'interval' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if timeout is None:
            raise TypeError("Missing 'timeout' argument")

        _setter("interval", interval)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("timeout", timeout)
        if http is not None:
            _setter("http", http)
        if retries is not None:
            _setter("retries", retries)

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        Interval how often the health check will be performed, in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port the health check tries to connect to, required if protocol is `tcp`. Can be everything between `1` and `65535`. Must be unique per Load Balancer.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol the health check uses. `http` or `tcp`
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        Timeout when a health check try will be canceled if there is no response, in seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.LoadBalancerServiceHealthCheckHttp']:
        """
        HTTP configuration. Required if `protocol` is `http`.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        Number of tries a health check will be performed until a target will be listed as `unhealthy`.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class LoadBalancerServiceHealthCheckHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerServiceHealthCheckHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerServiceHealthCheckHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerServiceHealthCheckHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 path: Optional[str] = None,
                 response: Optional[str] = None,
                 status_codes: Optional[Sequence[str]] = None,
                 tls: Optional[bool] = None):
        """
        :param str domain: Domain we try to access when performing the Health Check.
        :param str path: Path we try to access when performing the Health Check.
        :param str response: Response we expect to be included in the Target response when a Health Check was performed.
        :param Sequence[str] status_codes: We expect that the target answers with these status codes. If not the target is marked as `unhealthy`.
        :param bool tls: Enable TLS certificate checking.
        """
        LoadBalancerServiceHealthCheckHttp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            path=path,
            response=response,
            status_codes=status_codes,
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: Optional[str] = None,
             path: Optional[str] = None,
             response: Optional[str] = None,
             status_codes: Optional[Sequence[str]] = None,
             tls: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if status_codes is None and 'statusCodes' in kwargs:
            status_codes = kwargs['statusCodes']

        if domain is not None:
            _setter("domain", domain)
        if path is not None:
            _setter("path", path)
        if response is not None:
            _setter("response", response)
        if status_codes is not None:
            _setter("status_codes", status_codes)
        if tls is not None:
            _setter("tls", tls)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Domain we try to access when performing the Health Check.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path we try to access when performing the Health Check.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        Response we expect to be included in the Target response when a Health Check was performed.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence[str]]:
        """
        We expect that the target answers with these status codes. If not the target is marked as `unhealthy`.
        """
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter
    def tls(self) -> Optional[bool]:
        """
        Enable TLS certificate checking.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class LoadBalancerServiceHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieLifetime":
            suggest = "cookie_lifetime"
        elif key == "cookieName":
            suggest = "cookie_name"
        elif key == "redirectHttp":
            suggest = "redirect_http"
        elif key == "stickySessions":
            suggest = "sticky_sessions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerServiceHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerServiceHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerServiceHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificates: Optional[Sequence[int]] = None,
                 cookie_lifetime: Optional[int] = None,
                 cookie_name: Optional[str] = None,
                 redirect_http: Optional[bool] = None,
                 sticky_sessions: Optional[bool] = None):
        """
        :param Sequence[int] certificates: List of IDs from certificates which the Load Balancer has.
        :param int cookie_lifetime: Lifetime of the cookie for sticky session (in seconds). Default: `300`
        :param str cookie_name: Name of the cookie for sticky session. Default: `HCLBSTICKY`
        :param bool redirect_http: Redirect HTTP to HTTPS traffic. Only supported for services with `protocol` `https` using the default HTTP port `80`.
        :param bool sticky_sessions: Enable sticky sessions
        """
        LoadBalancerServiceHttp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
            cookie_lifetime=cookie_lifetime,
            cookie_name=cookie_name,
            redirect_http=redirect_http,
            sticky_sessions=sticky_sessions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Optional[Sequence[int]] = None,
             cookie_lifetime: Optional[int] = None,
             cookie_name: Optional[str] = None,
             redirect_http: Optional[bool] = None,
             sticky_sessions: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if cookie_lifetime is None and 'cookieLifetime' in kwargs:
            cookie_lifetime = kwargs['cookieLifetime']
        if cookie_name is None and 'cookieName' in kwargs:
            cookie_name = kwargs['cookieName']
        if redirect_http is None and 'redirectHttp' in kwargs:
            redirect_http = kwargs['redirectHttp']
        if sticky_sessions is None and 'stickySessions' in kwargs:
            sticky_sessions = kwargs['stickySessions']

        if certificates is not None:
            _setter("certificates", certificates)
        if cookie_lifetime is not None:
            _setter("cookie_lifetime", cookie_lifetime)
        if cookie_name is not None:
            _setter("cookie_name", cookie_name)
        if redirect_http is not None:
            _setter("redirect_http", redirect_http)
        if sticky_sessions is not None:
            _setter("sticky_sessions", sticky_sessions)

    @property
    @pulumi.getter
    def certificates(self) -> Optional[Sequence[int]]:
        """
        List of IDs from certificates which the Load Balancer has.
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="cookieLifetime")
    def cookie_lifetime(self) -> Optional[int]:
        """
        Lifetime of the cookie for sticky session (in seconds). Default: `300`
        """
        return pulumi.get(self, "cookie_lifetime")

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[str]:
        """
        Name of the cookie for sticky session. Default: `HCLBSTICKY`
        """
        return pulumi.get(self, "cookie_name")

    @property
    @pulumi.getter(name="redirectHttp")
    def redirect_http(self) -> Optional[bool]:
        """
        Redirect HTTP to HTTPS traffic. Only supported for services with `protocol` `https` using the default HTTP port `80`.
        """
        return pulumi.get(self, "redirect_http")

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> Optional[bool]:
        """
        Enable sticky sessions
        """
        return pulumi.get(self, "sticky_sessions")


@pulumi.output_type
class LoadBalancerTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverId":
            suggest = "server_id"
        elif key == "usePrivateIp":
            suggest = "use_private_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 server_id: Optional[int] = None,
                 use_private_ip: Optional[bool] = None):
        """
        :param str type: Type of the Load Balancer Algorithm. `round_robin` or `least_connections`
        """
        LoadBalancerTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            server_id=server_id,
            use_private_ip=use_private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             server_id: Optional[int] = None,
             use_private_ip: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if server_id is None and 'serverId' in kwargs:
            server_id = kwargs['serverId']
        if use_private_ip is None and 'usePrivateIp' in kwargs:
            use_private_ip = kwargs['usePrivateIp']

        _setter("type", type)
        if server_id is not None:
            _setter("server_id", server_id)
        if use_private_ip is not None:
            _setter("use_private_ip", use_private_ip)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the Load Balancer Algorithm. `round_robin` or `least_connections`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> Optional[int]:
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter(name="usePrivateIp")
    def use_private_ip(self) -> Optional[bool]:
        warnings.warn("""Does not work. Use the hcloud_load_balancer_target resource instead.""", DeprecationWarning)
        pulumi.log.warn("""use_private_ip is deprecated: Does not work. Use the hcloud_load_balancer_target resource instead.""")

        return pulumi.get(self, "use_private_ip")


@pulumi.output_type
class ServerNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "aliasIps":
            suggest = "alias_ips"
        elif key == "macAddress":
            suggest = "mac_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: int,
                 alias_ips: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None,
                 mac_address: Optional[str] = None):
        """
        :param int network_id: ID of the network
        :param Sequence[str] alias_ips: Alias IPs the server should have in the Network.
        :param str ip: Specify the IP the server should get in the network
        :param str mac_address: (Optional, string) The MAC address the private interface of the server has
        """
        ServerNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            alias_ips=alias_ips,
            ip=ip,
            mac_address=mac_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: Optional[int] = None,
             alias_ips: Optional[Sequence[str]] = None,
             ip: Optional[str] = None,
             mac_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if network_id is None and 'networkId' in kwargs:
            network_id = kwargs['networkId']
        if network_id is None:
            raise TypeError("Missing 'network_id' argument")
        if alias_ips is None and 'aliasIps' in kwargs:
            alias_ips = kwargs['aliasIps']
        if mac_address is None and 'macAddress' in kwargs:
            mac_address = kwargs['macAddress']

        _setter("network_id", network_id)
        if alias_ips is not None:
            _setter("alias_ips", alias_ips)
        if ip is not None:
            _setter("ip", ip)
        if mac_address is not None:
            _setter("mac_address", mac_address)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> int:
        """
        ID of the network
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="aliasIps")
    def alias_ips(self) -> Optional[Sequence[str]]:
        """
        Alias IPs the server should have in the Network.
        """
        return pulumi.get(self, "alias_ips")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Specify the IP the server should get in the network
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        (Optional, string) The MAC address the private interface of the server has
        """
        return pulumi.get(self, "mac_address")


@pulumi.output_type
class ServerPublicNet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Enabled":
            suggest = "ipv4_enabled"
        elif key == "ipv6Enabled":
            suggest = "ipv6_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerPublicNet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerPublicNet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerPublicNet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4: Optional[int] = None,
                 ipv4_enabled: Optional[bool] = None,
                 ipv6: Optional[int] = None,
                 ipv6_enabled: Optional[bool] = None):
        ServerPublicNet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv4=ipv4,
            ipv4_enabled=ipv4_enabled,
            ipv6=ipv6,
            ipv6_enabled=ipv6_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv4: Optional[int] = None,
             ipv4_enabled: Optional[bool] = None,
             ipv6: Optional[int] = None,
             ipv6_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ipv4_enabled is None and 'ipv4Enabled' in kwargs:
            ipv4_enabled = kwargs['ipv4Enabled']
        if ipv6_enabled is None and 'ipv6Enabled' in kwargs:
            ipv6_enabled = kwargs['ipv6Enabled']

        if ipv4 is not None:
            _setter("ipv4", ipv4)
        if ipv4_enabled is not None:
            _setter("ipv4_enabled", ipv4_enabled)
        if ipv6 is not None:
            _setter("ipv6", ipv6)
        if ipv6_enabled is not None:
            _setter("ipv6_enabled", ipv6_enabled)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[int]:
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter(name="ipv4Enabled")
    def ipv4_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "ipv4_enabled")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[int]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Enabled")
    def ipv6_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "ipv6_enabled")


@pulumi.output_type
class GetCertificatesCertificateResult(dict):
    def __init__(__self__, *,
                 certificate: str,
                 created: str,
                 domain_names: Sequence[str],
                 fingerprint: str,
                 id: int,
                 labels: Mapping[str, Any],
                 not_valid_after: str,
                 not_valid_before: str,
                 type: str,
                 name: Optional[str] = None):
        GetCertificatesCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate=certificate,
            created=created,
            domain_names=domain_names,
            fingerprint=fingerprint,
            id=id,
            labels=labels,
            not_valid_after=not_valid_after,
            not_valid_before=not_valid_before,
            type=type,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate: Optional[str] = None,
             created: Optional[str] = None,
             domain_names: Optional[Sequence[str]] = None,
             fingerprint: Optional[str] = None,
             id: Optional[int] = None,
             labels: Optional[Mapping[str, Any]] = None,
             not_valid_after: Optional[str] = None,
             not_valid_before: Optional[str] = None,
             type: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if certificate is None:
            raise TypeError("Missing 'certificate' argument")
        if created is None:
            raise TypeError("Missing 'created' argument")
        if domain_names is None and 'domainNames' in kwargs:
            domain_names = kwargs['domainNames']
        if domain_names is None:
            raise TypeError("Missing 'domain_names' argument")
        if fingerprint is None:
            raise TypeError("Missing 'fingerprint' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if labels is None:
            raise TypeError("Missing 'labels' argument")
        if not_valid_after is None and 'notValidAfter' in kwargs:
            not_valid_after = kwargs['notValidAfter']
        if not_valid_after is None:
            raise TypeError("Missing 'not_valid_after' argument")
        if not_valid_before is None and 'notValidBefore' in kwargs:
            not_valid_before = kwargs['notValidBefore']
        if not_valid_before is None:
            raise TypeError("Missing 'not_valid_before' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("certificate", certificate)
        _setter("created", created)
        _setter("domain_names", domain_names)
        _setter("fingerprint", fingerprint)
        _setter("id", id)
        _setter("labels", labels)
        _setter("not_valid_after", not_valid_after)
        _setter("not_valid_before", not_valid_before)
        _setter("type", type)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def created(self) -> str:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Sequence[str]:
        return pulumi.get(self, "domain_names")

    @property
    @pulumi.getter
    def fingerprint(self) -> str:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, Any]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="notValidAfter")
    def not_valid_after(self) -> str:
        return pulumi.get(self, "not_valid_after")

    @property
    @pulumi.getter(name="notValidBefore")
    def not_valid_before(self) -> str:
        return pulumi.get(self, "not_valid_before")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatacentersDatacenterResult(dict):
    def __init__(__self__, *,
                 available_server_type_ids: Sequence[int],
                 description: str,
                 id: int,
                 location: Mapping[str, Any],
                 name: str,
                 supported_server_type_ids: Sequence[int]):
        GetDatacentersDatacenterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_server_type_ids=available_server_type_ids,
            description=description,
            id=id,
            location=location,
            name=name,
            supported_server_type_ids=supported_server_type_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_server_type_ids: Optional[Sequence[int]] = None,
             description: Optional[str] = None,
             id: Optional[int] = None,
             location: Optional[Mapping[str, Any]] = None,
             name: Optional[str] = None,
             supported_server_type_ids: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if available_server_type_ids is None and 'availableServerTypeIds' in kwargs:
            available_server_type_ids = kwargs['availableServerTypeIds']
        if available_server_type_ids is None:
            raise TypeError("Missing 'available_server_type_ids' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if location is None:
            raise TypeError("Missing 'location' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if supported_server_type_ids is None and 'supportedServerTypeIds' in kwargs:
            supported_server_type_ids = kwargs['supportedServerTypeIds']
        if supported_server_type_ids is None:
            raise TypeError("Missing 'supported_server_type_ids' argument")

        _setter("available_server_type_ids", available_server_type_ids)
        _setter("description", description)
        _setter("id", id)
        _setter("location", location)
        _setter("name", name)
        _setter("supported_server_type_ids", supported_server_type_ids)

    @property
    @pulumi.getter(name="availableServerTypeIds")
    def available_server_type_ids(self) -> Sequence[int]:
        return pulumi.get(self, "available_server_type_ids")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Mapping[str, Any]:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="supportedServerTypeIds")
    def supported_server_type_ids(self) -> Sequence[int]:
        return pulumi.get(self, "supported_server_type_ids")


@pulumi.output_type
class GetFirewallApplyToResult(dict):
    def __init__(__self__, *,
                 label_selector: str,
                 server: int):
        """
        :param str label_selector: (string) Label Selector to select servers the firewall is applied to. Empty if a server is directly
               referenced
        :param int server: (int) ID of a server where the firewall is applied to. `0` if applied to a label_selector
        """
        GetFirewallApplyToResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_selector=label_selector,
            server=server,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_selector: Optional[str] = None,
             server: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if label_selector is None and 'labelSelector' in kwargs:
            label_selector = kwargs['labelSelector']
        if label_selector is None:
            raise TypeError("Missing 'label_selector' argument")
        if server is None:
            raise TypeError("Missing 'server' argument")

        _setter("label_selector", label_selector)
        _setter("server", server)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> str:
        """
        (string) Label Selector to select servers the firewall is applied to. Empty if a server is directly
        referenced
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def server(self) -> int:
        """
        (int) ID of a server where the firewall is applied to. `0` if applied to a label_selector
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class GetFirewallRuleResult(dict):
    def __init__(__self__, *,
                 direction: str,
                 description: Optional[str] = None,
                 destination_ips: Optional[Sequence[str]] = None,
                 port: Optional[str] = None,
                 protocol: Optional[str] = None,
                 source_ips: Optional[Sequence[str]] = None):
        """
        :param str direction: (Required, string) Direction of the Firewall Rule. `in`, `out`
        :param str description: (Optional, string) Description of the firewall rule
        :param Sequence[str] destination_ips: (Required, List) List of CIDRs that are allowed within this Firewall Rule (when `direction` is `out`)
        :param str port: (Required, string) Port of the Firewall Rule. Required when `protocol` is `tcp` or `udp`
        :param str protocol: (Required, string) Protocol of the Firewall Rule. `tcp`, `icmp`, `udp`, `gre`, `esp`
        :param Sequence[str] source_ips: (Required, List) List of CIDRs that are allowed within this Firewall Rule (when `direction` is `in`)
        """
        GetFirewallRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            description=description,
            destination_ips=destination_ips,
            port=port,
            protocol=protocol,
            source_ips=source_ips,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: Optional[str] = None,
             description: Optional[str] = None,
             destination_ips: Optional[Sequence[str]] = None,
             port: Optional[str] = None,
             protocol: Optional[str] = None,
             source_ips: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if destination_ips is None and 'destinationIps' in kwargs:
            destination_ips = kwargs['destinationIps']
        if source_ips is None and 'sourceIps' in kwargs:
            source_ips = kwargs['sourceIps']

        _setter("direction", direction)
        if description is not None:
            _setter("description", description)
        if destination_ips is not None:
            _setter("destination_ips", destination_ips)
        if port is not None:
            _setter("port", port)
        if protocol is not None:
            _setter("protocol", protocol)
        if source_ips is not None:
            _setter("source_ips", source_ips)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        (Required, string) Direction of the Firewall Rule. `in`, `out`
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Optional, string) Description of the firewall rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationIps")
    def destination_ips(self) -> Optional[Sequence[str]]:
        """
        (Required, List) List of CIDRs that are allowed within this Firewall Rule (when `direction` is `out`)
        """
        return pulumi.get(self, "destination_ips")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        (Required, string) Port of the Firewall Rule. Required when `protocol` is `tcp` or `udp`
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        (Required, string) Protocol of the Firewall Rule. `tcp`, `icmp`, `udp`, `gre`, `esp`
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Optional[Sequence[str]]:
        """
        (Required, List) List of CIDRs that are allowed within this Firewall Rule (when `direction` is `in`)
        """
        return pulumi.get(self, "source_ips")


@pulumi.output_type
class GetFirewallsFirewallResult(dict):
    def __init__(__self__, *,
                 name: str,
                 apply_tos: Optional[Sequence['outputs.GetFirewallsFirewallApplyToResult']] = None,
                 id: Optional[int] = None,
                 labels: Optional[Mapping[str, Any]] = None,
                 rules: Optional[Sequence['outputs.GetFirewallsFirewallRuleResult']] = None):
        GetFirewallsFirewallResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            apply_tos=apply_tos,
            id=id,
            labels=labels,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             apply_tos: Optional[Sequence['outputs.GetFirewallsFirewallApplyToResult']] = None,
             id: Optional[int] = None,
             labels: Optional[Mapping[str, Any]] = None,
             rules: Optional[Sequence['outputs.GetFirewallsFirewallRuleResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if apply_tos is None and 'applyTos' in kwargs:
            apply_tos = kwargs['applyTos']

        _setter("name", name)
        if apply_tos is not None:
            _setter("apply_tos", apply_tos)
        if id is not None:
            _setter("id", id)
        if labels is not None:
            _setter("labels", labels)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="applyTos")
    def apply_tos(self) -> Optional[Sequence['outputs.GetFirewallsFirewallApplyToResult']]:
        return pulumi.get(self, "apply_tos")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.GetFirewallsFirewallRuleResult']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetFirewallsFirewallApplyToResult(dict):
    def __init__(__self__, *,
                 label_selector: str,
                 server: int):
        GetFirewallsFirewallApplyToResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_selector=label_selector,
            server=server,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_selector: Optional[str] = None,
             server: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if label_selector is None and 'labelSelector' in kwargs:
            label_selector = kwargs['labelSelector']
        if label_selector is None:
            raise TypeError("Missing 'label_selector' argument")
        if server is None:
            raise TypeError("Missing 'server' argument")

        _setter("label_selector", label_selector)
        _setter("server", server)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> str:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def server(self) -> int:
        return pulumi.get(self, "server")


@pulumi.output_type
class GetFirewallsFirewallRuleResult(dict):
    def __init__(__self__, *,
                 direction: str,
                 description: Optional[str] = None,
                 destination_ips: Optional[Sequence[str]] = None,
                 port: Optional[str] = None,
                 protocol: Optional[str] = None,
                 source_ips: Optional[Sequence[str]] = None):
        GetFirewallsFirewallRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            description=description,
            destination_ips=destination_ips,
            port=port,
            protocol=protocol,
            source_ips=source_ips,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: Optional[str] = None,
             description: Optional[str] = None,
             destination_ips: Optional[Sequence[str]] = None,
             port: Optional[str] = None,
             protocol: Optional[str] = None,
             source_ips: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if destination_ips is None and 'destinationIps' in kwargs:
            destination_ips = kwargs['destinationIps']
        if source_ips is None and 'sourceIps' in kwargs:
            source_ips = kwargs['sourceIps']

        _setter("direction", direction)
        if description is not None:
            _setter("description", description)
        if destination_ips is not None:
            _setter("destination_ips", destination_ips)
        if port is not None:
            _setter("port", port)
        if protocol is not None:
            _setter("protocol", protocol)
        if source_ips is not None:
            _setter("source_ips", source_ips)

    @property
    @pulumi.getter
    def direction(self) -> str:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationIps")
    def destination_ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "destination_ips")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "source_ips")


@pulumi.output_type
class GetFloatingIpsFloatingIpResult(dict):
    def __init__(__self__, *,
                 delete_protection: bool,
                 description: str,
                 home_location: str,
                 id: int,
                 ip_address: str,
                 ip_network: str,
                 labels: Mapping[str, Any],
                 server_id: int,
                 type: str,
                 name: Optional[str] = None):
        GetFloatingIpsFloatingIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_protection=delete_protection,
            description=description,
            home_location=home_location,
            id=id,
            ip_address=ip_address,
            ip_network=ip_network,
            labels=labels,
            server_id=server_id,
            type=type,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_protection: Optional[bool] = None,
             description: Optional[str] = None,
             home_location: Optional[str] = None,
             id: Optional[int] = None,
             ip_address: Optional[str] = None,
             ip_network: Optional[str] = None,
             labels: Optional[Mapping[str, Any]] = None,
             server_id: Optional[int] = None,
             type: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if delete_protection is None and 'deleteProtection' in kwargs:
            delete_protection = kwargs['deleteProtection']
        if delete_protection is None:
            raise TypeError("Missing 'delete_protection' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if home_location is None and 'homeLocation' in kwargs:
            home_location = kwargs['homeLocation']
        if home_location is None:
            raise TypeError("Missing 'home_location' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if ip_address is None:
            raise TypeError("Missing 'ip_address' argument")
        if ip_network is None and 'ipNetwork' in kwargs:
            ip_network = kwargs['ipNetwork']
        if ip_network is None:
            raise TypeError("Missing 'ip_network' argument")
        if labels is None:
            raise TypeError("Missing 'labels' argument")
        if server_id is None and 'serverId' in kwargs:
            server_id = kwargs['serverId']
        if server_id is None:
            raise TypeError("Missing 'server_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("delete_protection", delete_protection)
        _setter("description", description)
        _setter("home_location", home_location)
        _setter("id", id)
        _setter("ip_address", ip_address)
        _setter("ip_network", ip_network)
        _setter("labels", labels)
        _setter("server_id", server_id)
        _setter("type", type)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="deleteProtection")
    def delete_protection(self) -> bool:
        return pulumi.get(self, "delete_protection")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="homeLocation")
    def home_location(self) -> str:
        return pulumi.get(self, "home_location")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="ipNetwork")
    def ip_network(self) -> str:
        return pulumi.get(self, "ip_network")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, Any]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> int:
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetImagesImageResult(dict):
    def __init__(__self__, *,
                 architecture: str,
                 created: str,
                 deprecated: str,
                 description: str,
                 id: int,
                 labels: Mapping[str, Any],
                 name: str,
                 os_flavor: str,
                 os_version: str,
                 rapid_deploy: bool,
                 type: str,
                 selector: Optional[str] = None):
        GetImagesImageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            architecture=architecture,
            created=created,
            deprecated=deprecated,
            description=description,
            id=id,
            labels=labels,
            name=name,
            os_flavor=os_flavor,
            os_version=os_version,
            rapid_deploy=rapid_deploy,
            type=type,
            selector=selector,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             architecture: Optional[str] = None,
             created: Optional[str] = None,
             deprecated: Optional[str] = None,
             description: Optional[str] = None,
             id: Optional[int] = None,
             labels: Optional[Mapping[str, Any]] = None,
             name: Optional[str] = None,
             os_flavor: Optional[str] = None,
             os_version: Optional[str] = None,
             rapid_deploy: Optional[bool] = None,
             type: Optional[str] = None,
             selector: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if architecture is None:
            raise TypeError("Missing 'architecture' argument")
        if created is None:
            raise TypeError("Missing 'created' argument")
        if deprecated is None:
            raise TypeError("Missing 'deprecated' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if labels is None:
            raise TypeError("Missing 'labels' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if os_flavor is None and 'osFlavor' in kwargs:
            os_flavor = kwargs['osFlavor']
        if os_flavor is None:
            raise TypeError("Missing 'os_flavor' argument")
        if os_version is None and 'osVersion' in kwargs:
            os_version = kwargs['osVersion']
        if os_version is None:
            raise TypeError("Missing 'os_version' argument")
        if rapid_deploy is None and 'rapidDeploy' in kwargs:
            rapid_deploy = kwargs['rapidDeploy']
        if rapid_deploy is None:
            raise TypeError("Missing 'rapid_deploy' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("architecture", architecture)
        _setter("created", created)
        _setter("deprecated", deprecated)
        _setter("description", description)
        _setter("id", id)
        _setter("labels", labels)
        _setter("name", name)
        _setter("os_flavor", os_flavor)
        _setter("os_version", os_version)
        _setter("rapid_deploy", rapid_deploy)
        _setter("type", type)
        if selector is not None:
            _setter("selector", selector)

    @property
    @pulumi.getter
    def architecture(self) -> str:
        return pulumi.get(self, "architecture")

    @property
    @pulumi.getter
    def created(self) -> str:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def deprecated(self) -> str:
        return pulumi.get(self, "deprecated")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, Any]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osFlavor")
    def os_flavor(self) -> str:
        return pulumi.get(self, "os_flavor")

    @property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> str:
        return pulumi.get(self, "os_version")

    @property
    @pulumi.getter(name="rapidDeploy")
    def rapid_deploy(self) -> bool:
        return pulumi.get(self, "rapid_deploy")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        warnings.warn("""Please use the with_selector property instead.""", DeprecationWarning)
        pulumi.log.warn("""selector is deprecated: Please use the with_selector property instead.""")

        return pulumi.get(self, "selector")


@pulumi.output_type
class GetLoadBalancerAlgorithmResult(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: (string) Type of the target. `server` or `label_selector`
        """
        GetLoadBalancerAlgorithmResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        (string) Type of the target. `server` or `label_selector`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLoadBalancerServiceResult(dict):
    def __init__(__self__, *,
                 destination_port: int,
                 health_checks: Sequence['outputs.GetLoadBalancerServiceHealthCheckResult'],
                 https: Sequence['outputs.GetLoadBalancerServiceHttpResult'],
                 listen_port: int,
                 protocol: str,
                 proxyprotocol: bool):
        """
        :param int destination_port: (int) Port the service connects to the targets on. Can be everything between `1` and `65535`.
        :param Sequence['GetLoadBalancerServiceHealthCheckArgs'] health_checks: (list) List of http configurations when `protocol` is `http` or `https`.
        :param Sequence['GetLoadBalancerServiceHttpArgs'] https: (list) List of http configurations when `protocol` is `http` or `https`.
        :param int listen_port: (int) Port the service listen on`. Can be everything between `1` and `65535`. Must be unique per Load Balancer.
        :param str protocol: (string) Protocol the health check uses. `http`, `https` or `tcp`
        :param bool proxyprotocol: (bool) Enable proxyprotocol.
        """
        GetLoadBalancerServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_port=destination_port,
            health_checks=health_checks,
            https=https,
            listen_port=listen_port,
            protocol=protocol,
            proxyprotocol=proxyprotocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_port: Optional[int] = None,
             health_checks: Optional[Sequence['outputs.GetLoadBalancerServiceHealthCheckResult']] = None,
             https: Optional[Sequence['outputs.GetLoadBalancerServiceHttpResult']] = None,
             listen_port: Optional[int] = None,
             protocol: Optional[str] = None,
             proxyprotocol: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination_port is None and 'destinationPort' in kwargs:
            destination_port = kwargs['destinationPort']
        if destination_port is None:
            raise TypeError("Missing 'destination_port' argument")
        if health_checks is None and 'healthChecks' in kwargs:
            health_checks = kwargs['healthChecks']
        if health_checks is None:
            raise TypeError("Missing 'health_checks' argument")
        if https is None:
            raise TypeError("Missing 'https' argument")
        if listen_port is None and 'listenPort' in kwargs:
            listen_port = kwargs['listenPort']
        if listen_port is None:
            raise TypeError("Missing 'listen_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if proxyprotocol is None:
            raise TypeError("Missing 'proxyprotocol' argument")

        _setter("destination_port", destination_port)
        _setter("health_checks", health_checks)
        _setter("https", https)
        _setter("listen_port", listen_port)
        _setter("protocol", protocol)
        _setter("proxyprotocol", proxyprotocol)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> int:
        """
        (int) Port the service connects to the targets on. Can be everything between `1` and `65535`.
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Sequence['outputs.GetLoadBalancerServiceHealthCheckResult']:
        """
        (list) List of http configurations when `protocol` is `http` or `https`.
        """
        return pulumi.get(self, "health_checks")

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetLoadBalancerServiceHttpResult']:
        """
        (list) List of http configurations when `protocol` is `http` or `https`.
        """
        return pulumi.get(self, "https")

    @property
    @pulumi.getter(name="listenPort")
    def listen_port(self) -> int:
        """
        (int) Port the service listen on`. Can be everything between `1` and `65535`. Must be unique per Load Balancer.
        """
        return pulumi.get(self, "listen_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        (string) Protocol the health check uses. `http`, `https` or `tcp`
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def proxyprotocol(self) -> bool:
        """
        (bool) Enable proxyprotocol.
        """
        return pulumi.get(self, "proxyprotocol")


@pulumi.output_type
class GetLoadBalancerServiceHealthCheckResult(dict):
    def __init__(__self__, *,
                 https: Sequence['outputs.GetLoadBalancerServiceHealthCheckHttpResult'],
                 interval: int,
                 port: int,
                 protocol: str,
                 retries: int,
                 timeout: int):
        """
        :param Sequence['GetLoadBalancerServiceHealthCheckHttpArgs'] https: (list) List of http configurations when `protocol` is `http` or `https`.
        :param int interval: (int) Interval how often the health check will be performed, in seconds.
        :param int port: (int) Port the health check tries to connect to. Can be everything between `1` and `65535`.
        :param str protocol: (string) Protocol the health check uses. `http`, `https` or `tcp`
        :param int retries: (int) Number of tries a health check will be performed until a target will be listed as `unhealthy`.
        :param int timeout: (int) Timeout when a health check try will be canceled if there is no response, in seconds.
        """
        GetLoadBalancerServiceHealthCheckResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            https=https,
            interval=interval,
            port=port,
            protocol=protocol,
            retries=retries,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             https: Optional[Sequence['outputs.GetLoadBalancerServiceHealthCheckHttpResult']] = None,
             interval: Optional[int] = None,
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             retries: Optional[int] = None,
             timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if https is None:
            raise TypeError("Missing 'https' argument")
        if interval is None:
            raise TypeError("Missing 'interval' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if retries is None:
            raise TypeError("Missing 'retries' argument")
        if timeout is None:
            raise TypeError("Missing 'timeout' argument")

        _setter("https", https)
        _setter("interval", interval)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("retries", retries)
        _setter("timeout", timeout)

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetLoadBalancerServiceHealthCheckHttpResult']:
        """
        (list) List of http configurations when `protocol` is `http` or `https`.
        """
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        (int) Interval how often the health check will be performed, in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        (int) Port the health check tries to connect to. Can be everything between `1` and `65535`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        (string) Protocol the health check uses. `http`, `https` or `tcp`
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def retries(self) -> int:
        """
        (int) Number of tries a health check will be performed until a target will be listed as `unhealthy`.
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        (int) Timeout when a health check try will be canceled if there is no response, in seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetLoadBalancerServiceHealthCheckHttpResult(dict):
    def __init__(__self__, *,
                 domain: str,
                 path: str,
                 response: str,
                 status_codes: Sequence[int],
                 tls: bool):
        """
        :param str domain: string) Domain we try to access when performing the Health Check.
        :param str path: (string) Path we try to access when performing the Health Check.
        :param str response: (string) Response we expect to be included in the Target response when a Health Check was performed.
        :param Sequence[int] status_codes: (list[int]) We expect that the target answers with these status codes. If not the target is marked as `unhealthy`.
        :param bool tls: (bool) Enable TLS certificate checking.
        """
        GetLoadBalancerServiceHealthCheckHttpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            path=path,
            response=response,
            status_codes=status_codes,
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: Optional[str] = None,
             path: Optional[str] = None,
             response: Optional[str] = None,
             status_codes: Optional[Sequence[int]] = None,
             tls: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if domain is None:
            raise TypeError("Missing 'domain' argument")
        if path is None:
            raise TypeError("Missing 'path' argument")
        if response is None:
            raise TypeError("Missing 'response' argument")
        if status_codes is None and 'statusCodes' in kwargs:
            status_codes = kwargs['statusCodes']
        if status_codes is None:
            raise TypeError("Missing 'status_codes' argument")
        if tls is None:
            raise TypeError("Missing 'tls' argument")

        _setter("domain", domain)
        _setter("path", path)
        _setter("response", response)
        _setter("status_codes", status_codes)
        _setter("tls", tls)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        string) Domain we try to access when performing the Health Check.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        (string) Path we try to access when performing the Health Check.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def response(self) -> str:
        """
        (string) Response we expect to be included in the Target response when a Health Check was performed.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence[int]:
        """
        (list[int]) We expect that the target answers with these status codes. If not the target is marked as `unhealthy`.
        """
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter
    def tls(self) -> bool:
        """
        (bool) Enable TLS certificate checking.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetLoadBalancerServiceHttpResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence[str],
                 cookie_lifetime: int,
                 cookie_name: str,
                 redirect_http: bool,
                 sticky_sessions: bool):
        """
        :param Sequence[str] certificates: (list[int]) List of IDs from certificates which the Load Balancer has.
        :param int cookie_lifetime: (int) Lifetime of the cookie for sticky session (in seconds).
        :param str cookie_name: (string) Name of the cookie for sticky session.
        :param bool redirect_http: (string) Determine if all requests from port 80 should be redirected to port 443.
        :param bool sticky_sessions: (string) Determine if sticky sessions are enabled or not.
        """
        GetLoadBalancerServiceHttpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
            cookie_lifetime=cookie_lifetime,
            cookie_name=cookie_name,
            redirect_http=redirect_http,
            sticky_sessions=sticky_sessions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Optional[Sequence[str]] = None,
             cookie_lifetime: Optional[int] = None,
             cookie_name: Optional[str] = None,
             redirect_http: Optional[bool] = None,
             sticky_sessions: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if certificates is None:
            raise TypeError("Missing 'certificates' argument")
        if cookie_lifetime is None and 'cookieLifetime' in kwargs:
            cookie_lifetime = kwargs['cookieLifetime']
        if cookie_lifetime is None:
            raise TypeError("Missing 'cookie_lifetime' argument")
        if cookie_name is None and 'cookieName' in kwargs:
            cookie_name = kwargs['cookieName']
        if cookie_name is None:
            raise TypeError("Missing 'cookie_name' argument")
        if redirect_http is None and 'redirectHttp' in kwargs:
            redirect_http = kwargs['redirectHttp']
        if redirect_http is None:
            raise TypeError("Missing 'redirect_http' argument")
        if sticky_sessions is None and 'stickySessions' in kwargs:
            sticky_sessions = kwargs['stickySessions']
        if sticky_sessions is None:
            raise TypeError("Missing 'sticky_sessions' argument")

        _setter("certificates", certificates)
        _setter("cookie_lifetime", cookie_lifetime)
        _setter("cookie_name", cookie_name)
        _setter("redirect_http", redirect_http)
        _setter("sticky_sessions", sticky_sessions)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence[str]:
        """
        (list[int]) List of IDs from certificates which the Load Balancer has.
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="cookieLifetime")
    def cookie_lifetime(self) -> int:
        """
        (int) Lifetime of the cookie for sticky session (in seconds).
        """
        return pulumi.get(self, "cookie_lifetime")

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> str:
        """
        (string) Name of the cookie for sticky session.
        """
        return pulumi.get(self, "cookie_name")

    @property
    @pulumi.getter(name="redirectHttp")
    def redirect_http(self) -> bool:
        """
        (string) Determine if all requests from port 80 should be redirected to port 443.
        """
        return pulumi.get(self, "redirect_http")

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> bool:
        """
        (string) Determine if sticky sessions are enabled or not.
        """
        return pulumi.get(self, "sticky_sessions")


@pulumi.output_type
class GetLoadBalancerTargetResult(dict):
    def __init__(__self__, *,
                 label_selector: str,
                 server_id: int,
                 type: str):
        """
        :param str label_selector: (string) Label Selector to add a group of resources based on the label.
        :param int server_id: (int) ID of the server which should be a target for this Load Balancer.
        :param str type: (string) Type of the target. `server` or `label_selector`
        """
        GetLoadBalancerTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_selector=label_selector,
            server_id=server_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_selector: Optional[str] = None,
             server_id: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if label_selector is None and 'labelSelector' in kwargs:
            label_selector = kwargs['labelSelector']
        if label_selector is None:
            raise TypeError("Missing 'label_selector' argument")
        if server_id is None and 'serverId' in kwargs:
            server_id = kwargs['serverId']
        if server_id is None:
            raise TypeError("Missing 'server_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("label_selector", label_selector)
        _setter("server_id", server_id)
        _setter("type", type)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> str:
        """
        (string) Label Selector to add a group of resources based on the label.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> int:
        """
        (int) ID of the server which should be a target for this Load Balancer.
        """
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        (string) Type of the target. `server` or `label_selector`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLoadBalancersLoadBalancerResult(dict):
    def __init__(__self__, *,
                 algorithms: Sequence['outputs.GetLoadBalancersLoadBalancerAlgorithmResult'],
                 delete_protection: bool,
                 id: int,
                 ipv4: str,
                 ipv6: str,
                 labels: Mapping[str, Any],
                 load_balancer_type: str,
                 location: str,
                 network_id: int,
                 network_ip: str,
                 network_zone: str,
                 services: Sequence['outputs.GetLoadBalancersLoadBalancerServiceResult'],
                 targets: Sequence['outputs.GetLoadBalancersLoadBalancerTargetResult'],
                 name: Optional[str] = None):
        GetLoadBalancersLoadBalancerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithms=algorithms,
            delete_protection=delete_protection,
            id=id,
            ipv4=ipv4,
            ipv6=ipv6,
            labels=labels,
            load_balancer_type=load_balancer_type,
            location=location,
            network_id=network_id,
            network_ip=network_ip,
            network_zone=network_zone,
            services=services,
            targets=targets,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithms: Optional[Sequence['outputs.GetLoadBalancersLoadBalancerAlgorithmResult']] = None,
             delete_protection: Optional[bool] = None,
             id: Optional[int] = None,
             ipv4: Optional[str] = None,
             ipv6: Optional[str] = None,
             labels: Optional[Mapping[str, Any]] = None,
             load_balancer_type: Optional[str] = None,
             location: Optional[str] = None,
             network_id: Optional[int] = None,
             network_ip: Optional[str] = None,
             network_zone: Optional[str] = None,
             services: Optional[Sequence['outputs.GetLoadBalancersLoadBalancerServiceResult']] = None,
             targets: Optional[Sequence['outputs.GetLoadBalancersLoadBalancerTargetResult']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if algorithms is None:
            raise TypeError("Missing 'algorithms' argument")
        if delete_protection is None and 'deleteProtection' in kwargs:
            delete_protection = kwargs['deleteProtection']
        if delete_protection is None:
            raise TypeError("Missing 'delete_protection' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ipv4 is None:
            raise TypeError("Missing 'ipv4' argument")
        if ipv6 is None:
            raise TypeError("Missing 'ipv6' argument")
        if labels is None:
            raise TypeError("Missing 'labels' argument")
        if load_balancer_type is None and 'loadBalancerType' in kwargs:
            load_balancer_type = kwargs['loadBalancerType']
        if load_balancer_type is None:
            raise TypeError("Missing 'load_balancer_type' argument")
        if location is None:
            raise TypeError("Missing 'location' argument")
        if network_id is None and 'networkId' in kwargs:
            network_id = kwargs['networkId']
        if network_id is None:
            raise TypeError("Missing 'network_id' argument")
        if network_ip is None and 'networkIp' in kwargs:
            network_ip = kwargs['networkIp']
        if network_ip is None:
            raise TypeError("Missing 'network_ip' argument")
        if network_zone is None and 'networkZone' in kwargs:
            network_zone = kwargs['networkZone']
        if network_zone is None:
            raise TypeError("Missing 'network_zone' argument")
        if services is None:
            raise TypeError("Missing 'services' argument")
        if targets is None:
            raise TypeError("Missing 'targets' argument")

        _setter("algorithms", algorithms)
        _setter("delete_protection", delete_protection)
        _setter("id", id)
        _setter("ipv4", ipv4)
        _setter("ipv6", ipv6)
        _setter("labels", labels)
        _setter("load_balancer_type", load_balancer_type)
        _setter("location", location)
        _setter("network_id", network_id)
        _setter("network_ip", network_ip)
        _setter("network_zone", network_zone)
        _setter("services", services)
        _setter("targets", targets)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def algorithms(self) -> Sequence['outputs.GetLoadBalancersLoadBalancerAlgorithmResult']:
        return pulumi.get(self, "algorithms")

    @property
    @pulumi.getter(name="deleteProtection")
    def delete_protection(self) -> bool:
        return pulumi.get(self, "delete_protection")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ipv4(self) -> str:
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> str:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, Any]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> str:
        return pulumi.get(self, "load_balancer_type")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> int:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> str:
        return pulumi.get(self, "network_ip")

    @property
    @pulumi.getter(name="networkZone")
    def network_zone(self) -> str:
        return pulumi.get(self, "network_zone")

    @property
    @pulumi.getter
    def services(self) -> Sequence['outputs.GetLoadBalancersLoadBalancerServiceResult']:
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetLoadBalancersLoadBalancerTargetResult']:
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetLoadBalancersLoadBalancerAlgorithmResult(dict):
    def __init__(__self__, *,
                 type: str):
        GetLoadBalancersLoadBalancerAlgorithmResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLoadBalancersLoadBalancerServiceResult(dict):
    def __init__(__self__, *,
                 destination_port: int,
                 health_checks: Sequence['outputs.GetLoadBalancersLoadBalancerServiceHealthCheckResult'],
                 https: Sequence['outputs.GetLoadBalancersLoadBalancerServiceHttpResult'],
                 listen_port: int,
                 protocol: str,
                 proxyprotocol: bool):
        GetLoadBalancersLoadBalancerServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_port=destination_port,
            health_checks=health_checks,
            https=https,
            listen_port=listen_port,
            protocol=protocol,
            proxyprotocol=proxyprotocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_port: Optional[int] = None,
             health_checks: Optional[Sequence['outputs.GetLoadBalancersLoadBalancerServiceHealthCheckResult']] = None,
             https: Optional[Sequence['outputs.GetLoadBalancersLoadBalancerServiceHttpResult']] = None,
             listen_port: Optional[int] = None,
             protocol: Optional[str] = None,
             proxyprotocol: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination_port is None and 'destinationPort' in kwargs:
            destination_port = kwargs['destinationPort']
        if destination_port is None:
            raise TypeError("Missing 'destination_port' argument")
        if health_checks is None and 'healthChecks' in kwargs:
            health_checks = kwargs['healthChecks']
        if health_checks is None:
            raise TypeError("Missing 'health_checks' argument")
        if https is None:
            raise TypeError("Missing 'https' argument")
        if listen_port is None and 'listenPort' in kwargs:
            listen_port = kwargs['listenPort']
        if listen_port is None:
            raise TypeError("Missing 'listen_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if proxyprotocol is None:
            raise TypeError("Missing 'proxyprotocol' argument")

        _setter("destination_port", destination_port)
        _setter("health_checks", health_checks)
        _setter("https", https)
        _setter("listen_port", listen_port)
        _setter("protocol", protocol)
        _setter("proxyprotocol", proxyprotocol)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> int:
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Sequence['outputs.GetLoadBalancersLoadBalancerServiceHealthCheckResult']:
        return pulumi.get(self, "health_checks")

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetLoadBalancersLoadBalancerServiceHttpResult']:
        return pulumi.get(self, "https")

    @property
    @pulumi.getter(name="listenPort")
    def listen_port(self) -> int:
        return pulumi.get(self, "listen_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def proxyprotocol(self) -> bool:
        return pulumi.get(self, "proxyprotocol")


@pulumi.output_type
class GetLoadBalancersLoadBalancerServiceHealthCheckResult(dict):
    def __init__(__self__, *,
                 https: Sequence['outputs.GetLoadBalancersLoadBalancerServiceHealthCheckHttpResult'],
                 interval: int,
                 port: int,
                 protocol: str,
                 retries: int,
                 timeout: int):
        GetLoadBalancersLoadBalancerServiceHealthCheckResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            https=https,
            interval=interval,
            port=port,
            protocol=protocol,
            retries=retries,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             https: Optional[Sequence['outputs.GetLoadBalancersLoadBalancerServiceHealthCheckHttpResult']] = None,
             interval: Optional[int] = None,
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             retries: Optional[int] = None,
             timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if https is None:
            raise TypeError("Missing 'https' argument")
        if interval is None:
            raise TypeError("Missing 'interval' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if retries is None:
            raise TypeError("Missing 'retries' argument")
        if timeout is None:
            raise TypeError("Missing 'timeout' argument")

        _setter("https", https)
        _setter("interval", interval)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("retries", retries)
        _setter("timeout", timeout)

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetLoadBalancersLoadBalancerServiceHealthCheckHttpResult']:
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def interval(self) -> int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def retries(self) -> int:
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetLoadBalancersLoadBalancerServiceHealthCheckHttpResult(dict):
    def __init__(__self__, *,
                 domain: str,
                 path: str,
                 response: str,
                 status_codes: Sequence[int],
                 tls: bool):
        GetLoadBalancersLoadBalancerServiceHealthCheckHttpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            path=path,
            response=response,
            status_codes=status_codes,
            tls=tls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: Optional[str] = None,
             path: Optional[str] = None,
             response: Optional[str] = None,
             status_codes: Optional[Sequence[int]] = None,
             tls: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if domain is None:
            raise TypeError("Missing 'domain' argument")
        if path is None:
            raise TypeError("Missing 'path' argument")
        if response is None:
            raise TypeError("Missing 'response' argument")
        if status_codes is None and 'statusCodes' in kwargs:
            status_codes = kwargs['statusCodes']
        if status_codes is None:
            raise TypeError("Missing 'status_codes' argument")
        if tls is None:
            raise TypeError("Missing 'tls' argument")

        _setter("domain", domain)
        _setter("path", path)
        _setter("response", response)
        _setter("status_codes", status_codes)
        _setter("tls", tls)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def response(self) -> str:
        return pulumi.get(self, "response")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence[int]:
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter
    def tls(self) -> bool:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetLoadBalancersLoadBalancerServiceHttpResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence[str],
                 cookie_lifetime: int,
                 cookie_name: str,
                 redirect_http: bool,
                 sticky_sessions: bool):
        GetLoadBalancersLoadBalancerServiceHttpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
            cookie_lifetime=cookie_lifetime,
            cookie_name=cookie_name,
            redirect_http=redirect_http,
            sticky_sessions=sticky_sessions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Optional[Sequence[str]] = None,
             cookie_lifetime: Optional[int] = None,
             cookie_name: Optional[str] = None,
             redirect_http: Optional[bool] = None,
             sticky_sessions: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if certificates is None:
            raise TypeError("Missing 'certificates' argument")
        if cookie_lifetime is None and 'cookieLifetime' in kwargs:
            cookie_lifetime = kwargs['cookieLifetime']
        if cookie_lifetime is None:
            raise TypeError("Missing 'cookie_lifetime' argument")
        if cookie_name is None and 'cookieName' in kwargs:
            cookie_name = kwargs['cookieName']
        if cookie_name is None:
            raise TypeError("Missing 'cookie_name' argument")
        if redirect_http is None and 'redirectHttp' in kwargs:
            redirect_http = kwargs['redirectHttp']
        if redirect_http is None:
            raise TypeError("Missing 'redirect_http' argument")
        if sticky_sessions is None and 'stickySessions' in kwargs:
            sticky_sessions = kwargs['stickySessions']
        if sticky_sessions is None:
            raise TypeError("Missing 'sticky_sessions' argument")

        _setter("certificates", certificates)
        _setter("cookie_lifetime", cookie_lifetime)
        _setter("cookie_name", cookie_name)
        _setter("redirect_http", redirect_http)
        _setter("sticky_sessions", sticky_sessions)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence[str]:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="cookieLifetime")
    def cookie_lifetime(self) -> int:
        return pulumi.get(self, "cookie_lifetime")

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> str:
        return pulumi.get(self, "cookie_name")

    @property
    @pulumi.getter(name="redirectHttp")
    def redirect_http(self) -> bool:
        return pulumi.get(self, "redirect_http")

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> bool:
        return pulumi.get(self, "sticky_sessions")


@pulumi.output_type
class GetLoadBalancersLoadBalancerTargetResult(dict):
    def __init__(__self__, *,
                 label_selector: str,
                 server_id: int,
                 type: str):
        GetLoadBalancersLoadBalancerTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_selector=label_selector,
            server_id=server_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_selector: Optional[str] = None,
             server_id: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if label_selector is None and 'labelSelector' in kwargs:
            label_selector = kwargs['labelSelector']
        if label_selector is None:
            raise TypeError("Missing 'label_selector' argument")
        if server_id is None and 'serverId' in kwargs:
            server_id = kwargs['serverId']
        if server_id is None:
            raise TypeError("Missing 'server_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("label_selector", label_selector)
        _setter("server_id", server_id)
        _setter("type", type)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> str:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> int:
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLocationsLocationResult(dict):
    def __init__(__self__, *,
                 city: str,
                 country: str,
                 description: str,
                 id: int,
                 latitude: float,
                 longitude: float,
                 name: str,
                 network_zone: str):
        GetLocationsLocationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            city=city,
            country=country,
            description=description,
            id=id,
            latitude=latitude,
            longitude=longitude,
            name=name,
            network_zone=network_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             city: Optional[str] = None,
             country: Optional[str] = None,
             description: Optional[str] = None,
             id: Optional[int] = None,
             latitude: Optional[float] = None,
             longitude: Optional[float] = None,
             name: Optional[str] = None,
             network_zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if city is None:
            raise TypeError("Missing 'city' argument")
        if country is None:
            raise TypeError("Missing 'country' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if latitude is None:
            raise TypeError("Missing 'latitude' argument")
        if longitude is None:
            raise TypeError("Missing 'longitude' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if network_zone is None and 'networkZone' in kwargs:
            network_zone = kwargs['networkZone']
        if network_zone is None:
            raise TypeError("Missing 'network_zone' argument")

        _setter("city", city)
        _setter("country", country)
        _setter("description", description)
        _setter("id", id)
        _setter("latitude", latitude)
        _setter("longitude", longitude)
        _setter("name", name)
        _setter("network_zone", network_zone)

    @property
    @pulumi.getter
    def city(self) -> str:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def country(self) -> str:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def latitude(self) -> float:
        return pulumi.get(self, "latitude")

    @property
    @pulumi.getter
    def longitude(self) -> float:
        return pulumi.get(self, "longitude")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkZone")
    def network_zone(self) -> str:
        return pulumi.get(self, "network_zone")


@pulumi.output_type
class GetNetworksNetworkResult(dict):
    def __init__(__self__, *,
                 delete_protection: bool,
                 expose_routes_to_vswitch: bool,
                 id: int,
                 ip_range: Optional[str] = None,
                 labels: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        GetNetworksNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_protection=delete_protection,
            expose_routes_to_vswitch=expose_routes_to_vswitch,
            id=id,
            ip_range=ip_range,
            labels=labels,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_protection: Optional[bool] = None,
             expose_routes_to_vswitch: Optional[bool] = None,
             id: Optional[int] = None,
             ip_range: Optional[str] = None,
             labels: Optional[Mapping[str, Any]] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if delete_protection is None and 'deleteProtection' in kwargs:
            delete_protection = kwargs['deleteProtection']
        if delete_protection is None:
            raise TypeError("Missing 'delete_protection' argument")
        if expose_routes_to_vswitch is None and 'exposeRoutesToVswitch' in kwargs:
            expose_routes_to_vswitch = kwargs['exposeRoutesToVswitch']
        if expose_routes_to_vswitch is None:
            raise TypeError("Missing 'expose_routes_to_vswitch' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ip_range is None and 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']

        _setter("delete_protection", delete_protection)
        _setter("expose_routes_to_vswitch", expose_routes_to_vswitch)
        _setter("id", id)
        if ip_range is not None:
            _setter("ip_range", ip_range)
        if labels is not None:
            _setter("labels", labels)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="deleteProtection")
    def delete_protection(self) -> bool:
        return pulumi.get(self, "delete_protection")

    @property
    @pulumi.getter(name="exposeRoutesToVswitch")
    def expose_routes_to_vswitch(self) -> bool:
        return pulumi.get(self, "expose_routes_to_vswitch")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[str]:
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPlacementGroupsPlacementGroupResult(dict):
    def __init__(__self__, *,
                 name: str,
                 servers: Sequence[int],
                 id: Optional[int] = None,
                 labels: Optional[Mapping[str, Any]] = None,
                 type: Optional[str] = None):
        GetPlacementGroupsPlacementGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            servers=servers,
            id=id,
            labels=labels,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             servers: Optional[Sequence[int]] = None,
             id: Optional[int] = None,
             labels: Optional[Mapping[str, Any]] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if servers is None:
            raise TypeError("Missing 'servers' argument")

        _setter("name", name)
        _setter("servers", servers)
        if id is not None:
            _setter("id", id)
        if labels is not None:
            _setter("labels", labels)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def servers(self) -> Sequence[int]:
        return pulumi.get(self, "servers")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPrimaryIpsPrimaryIpResult(dict):
    def __init__(__self__, *,
                 assignee_id: int,
                 assignee_type: str,
                 auto_delete: bool,
                 datacenter: str,
                 delete_protection: bool,
                 id: int,
                 ip_address: str,
                 ip_network: str,
                 labels: Mapping[str, Any],
                 type: str,
                 name: Optional[str] = None):
        GetPrimaryIpsPrimaryIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assignee_id=assignee_id,
            assignee_type=assignee_type,
            auto_delete=auto_delete,
            datacenter=datacenter,
            delete_protection=delete_protection,
            id=id,
            ip_address=ip_address,
            ip_network=ip_network,
            labels=labels,
            type=type,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assignee_id: Optional[int] = None,
             assignee_type: Optional[str] = None,
             auto_delete: Optional[bool] = None,
             datacenter: Optional[str] = None,
             delete_protection: Optional[bool] = None,
             id: Optional[int] = None,
             ip_address: Optional[str] = None,
             ip_network: Optional[str] = None,
             labels: Optional[Mapping[str, Any]] = None,
             type: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if assignee_id is None and 'assigneeId' in kwargs:
            assignee_id = kwargs['assigneeId']
        if assignee_id is None:
            raise TypeError("Missing 'assignee_id' argument")
        if assignee_type is None and 'assigneeType' in kwargs:
            assignee_type = kwargs['assigneeType']
        if assignee_type is None:
            raise TypeError("Missing 'assignee_type' argument")
        if auto_delete is None and 'autoDelete' in kwargs:
            auto_delete = kwargs['autoDelete']
        if auto_delete is None:
            raise TypeError("Missing 'auto_delete' argument")
        if datacenter is None:
            raise TypeError("Missing 'datacenter' argument")
        if delete_protection is None and 'deleteProtection' in kwargs:
            delete_protection = kwargs['deleteProtection']
        if delete_protection is None:
            raise TypeError("Missing 'delete_protection' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if ip_address is None:
            raise TypeError("Missing 'ip_address' argument")
        if ip_network is None and 'ipNetwork' in kwargs:
            ip_network = kwargs['ipNetwork']
        if ip_network is None:
            raise TypeError("Missing 'ip_network' argument")
        if labels is None:
            raise TypeError("Missing 'labels' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("assignee_id", assignee_id)
        _setter("assignee_type", assignee_type)
        _setter("auto_delete", auto_delete)
        _setter("datacenter", datacenter)
        _setter("delete_protection", delete_protection)
        _setter("id", id)
        _setter("ip_address", ip_address)
        _setter("ip_network", ip_network)
        _setter("labels", labels)
        _setter("type", type)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="assigneeId")
    def assignee_id(self) -> int:
        return pulumi.get(self, "assignee_id")

    @property
    @pulumi.getter(name="assigneeType")
    def assignee_type(self) -> str:
        return pulumi.get(self, "assignee_type")

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> bool:
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter
    def datacenter(self) -> str:
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter(name="deleteProtection")
    def delete_protection(self) -> bool:
        return pulumi.get(self, "delete_protection")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="ipNetwork")
    def ip_network(self) -> str:
        return pulumi.get(self, "ip_network")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, Any]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetServerTypesServerTypeResult(dict):
    def __init__(__self__, *,
                 architecture: str,
                 cores: int,
                 cpu_type: str,
                 deprecation_announced: str,
                 description: str,
                 disk: int,
                 id: int,
                 included_traffic: int,
                 is_deprecated: bool,
                 memory: int,
                 name: str,
                 storage_type: str,
                 unavailable_after: str):
        GetServerTypesServerTypeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            architecture=architecture,
            cores=cores,
            cpu_type=cpu_type,
            deprecation_announced=deprecation_announced,
            description=description,
            disk=disk,
            id=id,
            included_traffic=included_traffic,
            is_deprecated=is_deprecated,
            memory=memory,
            name=name,
            storage_type=storage_type,
            unavailable_after=unavailable_after,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             architecture: Optional[str] = None,
             cores: Optional[int] = None,
             cpu_type: Optional[str] = None,
             deprecation_announced: Optional[str] = None,
             description: Optional[str] = None,
             disk: Optional[int] = None,
             id: Optional[int] = None,
             included_traffic: Optional[int] = None,
             is_deprecated: Optional[bool] = None,
             memory: Optional[int] = None,
             name: Optional[str] = None,
             storage_type: Optional[str] = None,
             unavailable_after: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if architecture is None:
            raise TypeError("Missing 'architecture' argument")
        if cores is None:
            raise TypeError("Missing 'cores' argument")
        if cpu_type is None and 'cpuType' in kwargs:
            cpu_type = kwargs['cpuType']
        if cpu_type is None:
            raise TypeError("Missing 'cpu_type' argument")
        if deprecation_announced is None and 'deprecationAnnounced' in kwargs:
            deprecation_announced = kwargs['deprecationAnnounced']
        if deprecation_announced is None:
            raise TypeError("Missing 'deprecation_announced' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if disk is None:
            raise TypeError("Missing 'disk' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if included_traffic is None and 'includedTraffic' in kwargs:
            included_traffic = kwargs['includedTraffic']
        if included_traffic is None:
            raise TypeError("Missing 'included_traffic' argument")
        if is_deprecated is None and 'isDeprecated' in kwargs:
            is_deprecated = kwargs['isDeprecated']
        if is_deprecated is None:
            raise TypeError("Missing 'is_deprecated' argument")
        if memory is None:
            raise TypeError("Missing 'memory' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if storage_type is None and 'storageType' in kwargs:
            storage_type = kwargs['storageType']
        if storage_type is None:
            raise TypeError("Missing 'storage_type' argument")
        if unavailable_after is None and 'unavailableAfter' in kwargs:
            unavailable_after = kwargs['unavailableAfter']
        if unavailable_after is None:
            raise TypeError("Missing 'unavailable_after' argument")

        _setter("architecture", architecture)
        _setter("cores", cores)
        _setter("cpu_type", cpu_type)
        _setter("deprecation_announced", deprecation_announced)
        _setter("description", description)
        _setter("disk", disk)
        _setter("id", id)
        _setter("included_traffic", included_traffic)
        _setter("is_deprecated", is_deprecated)
        _setter("memory", memory)
        _setter("name", name)
        _setter("storage_type", storage_type)
        _setter("unavailable_after", unavailable_after)

    @property
    @pulumi.getter
    def architecture(self) -> str:
        return pulumi.get(self, "architecture")

    @property
    @pulumi.getter
    def cores(self) -> int:
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter(name="cpuType")
    def cpu_type(self) -> str:
        return pulumi.get(self, "cpu_type")

    @property
    @pulumi.getter(name="deprecationAnnounced")
    def deprecation_announced(self) -> str:
        return pulumi.get(self, "deprecation_announced")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def disk(self) -> int:
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includedTraffic")
    def included_traffic(self) -> int:
        return pulumi.get(self, "included_traffic")

    @property
    @pulumi.getter(name="isDeprecated")
    def is_deprecated(self) -> bool:
        return pulumi.get(self, "is_deprecated")

    @property
    @pulumi.getter
    def memory(self) -> int:
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> str:
        return pulumi.get(self, "storage_type")

    @property
    @pulumi.getter(name="unavailableAfter")
    def unavailable_after(self) -> str:
        return pulumi.get(self, "unavailable_after")


@pulumi.output_type
class GetServersServerResult(dict):
    def __init__(__self__, *,
                 backup_window: str,
                 backups: bool,
                 datacenter: str,
                 delete_protection: bool,
                 firewall_ids: Sequence[int],
                 id: int,
                 image: str,
                 ipv4_address: str,
                 ipv6_address: str,
                 ipv6_network: str,
                 iso: str,
                 labels: Mapping[str, Any],
                 location: str,
                 name: str,
                 rebuild_protection: bool,
                 rescue: str,
                 server_type: str,
                 status: str,
                 placement_group_id: Optional[int] = None):
        GetServersServerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_window=backup_window,
            backups=backups,
            datacenter=datacenter,
            delete_protection=delete_protection,
            firewall_ids=firewall_ids,
            id=id,
            image=image,
            ipv4_address=ipv4_address,
            ipv6_address=ipv6_address,
            ipv6_network=ipv6_network,
            iso=iso,
            labels=labels,
            location=location,
            name=name,
            rebuild_protection=rebuild_protection,
            rescue=rescue,
            server_type=server_type,
            status=status,
            placement_group_id=placement_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_window: Optional[str] = None,
             backups: Optional[bool] = None,
             datacenter: Optional[str] = None,
             delete_protection: Optional[bool] = None,
             firewall_ids: Optional[Sequence[int]] = None,
             id: Optional[int] = None,
             image: Optional[str] = None,
             ipv4_address: Optional[str] = None,
             ipv6_address: Optional[str] = None,
             ipv6_network: Optional[str] = None,
             iso: Optional[str] = None,
             labels: Optional[Mapping[str, Any]] = None,
             location: Optional[str] = None,
             name: Optional[str] = None,
             rebuild_protection: Optional[bool] = None,
             rescue: Optional[str] = None,
             server_type: Optional[str] = None,
             status: Optional[str] = None,
             placement_group_id: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if backup_window is None and 'backupWindow' in kwargs:
            backup_window = kwargs['backupWindow']
        if backup_window is None:
            raise TypeError("Missing 'backup_window' argument")
        if backups is None:
            raise TypeError("Missing 'backups' argument")
        if datacenter is None:
            raise TypeError("Missing 'datacenter' argument")
        if delete_protection is None and 'deleteProtection' in kwargs:
            delete_protection = kwargs['deleteProtection']
        if delete_protection is None:
            raise TypeError("Missing 'delete_protection' argument")
        if firewall_ids is None and 'firewallIds' in kwargs:
            firewall_ids = kwargs['firewallIds']
        if firewall_ids is None:
            raise TypeError("Missing 'firewall_ids' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image is None:
            raise TypeError("Missing 'image' argument")
        if ipv4_address is None and 'ipv4Address' in kwargs:
            ipv4_address = kwargs['ipv4Address']
        if ipv4_address is None:
            raise TypeError("Missing 'ipv4_address' argument")
        if ipv6_address is None and 'ipv6Address' in kwargs:
            ipv6_address = kwargs['ipv6Address']
        if ipv6_address is None:
            raise TypeError("Missing 'ipv6_address' argument")
        if ipv6_network is None and 'ipv6Network' in kwargs:
            ipv6_network = kwargs['ipv6Network']
        if ipv6_network is None:
            raise TypeError("Missing 'ipv6_network' argument")
        if iso is None:
            raise TypeError("Missing 'iso' argument")
        if labels is None:
            raise TypeError("Missing 'labels' argument")
        if location is None:
            raise TypeError("Missing 'location' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if rebuild_protection is None and 'rebuildProtection' in kwargs:
            rebuild_protection = kwargs['rebuildProtection']
        if rebuild_protection is None:
            raise TypeError("Missing 'rebuild_protection' argument")
        if rescue is None:
            raise TypeError("Missing 'rescue' argument")
        if server_type is None and 'serverType' in kwargs:
            server_type = kwargs['serverType']
        if server_type is None:
            raise TypeError("Missing 'server_type' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if placement_group_id is None and 'placementGroupId' in kwargs:
            placement_group_id = kwargs['placementGroupId']

        _setter("backup_window", backup_window)
        _setter("backups", backups)
        _setter("datacenter", datacenter)
        _setter("delete_protection", delete_protection)
        _setter("firewall_ids", firewall_ids)
        _setter("id", id)
        _setter("image", image)
        _setter("ipv4_address", ipv4_address)
        _setter("ipv6_address", ipv6_address)
        _setter("ipv6_network", ipv6_network)
        _setter("iso", iso)
        _setter("labels", labels)
        _setter("location", location)
        _setter("name", name)
        _setter("rebuild_protection", rebuild_protection)
        _setter("rescue", rescue)
        _setter("server_type", server_type)
        _setter("status", status)
        if placement_group_id is not None:
            _setter("placement_group_id", placement_group_id)

    @property
    @pulumi.getter(name="backupWindow")
    def backup_window(self) -> str:
        return pulumi.get(self, "backup_window")

    @property
    @pulumi.getter
    def backups(self) -> bool:
        return pulumi.get(self, "backups")

    @property
    @pulumi.getter
    def datacenter(self) -> str:
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter(name="deleteProtection")
    def delete_protection(self) -> bool:
        return pulumi.get(self, "delete_protection")

    @property
    @pulumi.getter(name="firewallIds")
    def firewall_ids(self) -> Sequence[int]:
        return pulumi.get(self, "firewall_ids")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> str:
        return pulumi.get(self, "ipv4_address")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="ipv6Network")
    def ipv6_network(self) -> str:
        return pulumi.get(self, "ipv6_network")

    @property
    @pulumi.getter
    def iso(self) -> str:
        return pulumi.get(self, "iso")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, Any]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="rebuildProtection")
    def rebuild_protection(self) -> bool:
        return pulumi.get(self, "rebuild_protection")

    @property
    @pulumi.getter
    def rescue(self) -> str:
        return pulumi.get(self, "rescue")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> str:
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[int]:
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class GetSshKeysSshKeyResult(dict):
    def __init__(__self__, *,
                 fingerprint: str,
                 id: int,
                 labels: Mapping[str, Any],
                 name: str,
                 public_key: str):
        GetSshKeysSshKeyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fingerprint=fingerprint,
            id=id,
            labels=labels,
            name=name,
            public_key=public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fingerprint: Optional[str] = None,
             id: Optional[int] = None,
             labels: Optional[Mapping[str, Any]] = None,
             name: Optional[str] = None,
             public_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if fingerprint is None:
            raise TypeError("Missing 'fingerprint' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if labels is None:
            raise TypeError("Missing 'labels' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if public_key is None and 'publicKey' in kwargs:
            public_key = kwargs['publicKey']
        if public_key is None:
            raise TypeError("Missing 'public_key' argument")

        _setter("fingerprint", fingerprint)
        _setter("id", id)
        _setter("labels", labels)
        _setter("name", name)
        _setter("public_key", public_key)

    @property
    @pulumi.getter
    def fingerprint(self) -> str:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, Any]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetVolumesVolumeResult(dict):
    def __init__(__self__, *,
                 delete_protection: bool,
                 id: int,
                 labels: Mapping[str, Any],
                 linux_device: str,
                 name: str,
                 size: int,
                 location: Optional[str] = None,
                 server_id: Optional[int] = None):
        GetVolumesVolumeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_protection=delete_protection,
            id=id,
            labels=labels,
            linux_device=linux_device,
            name=name,
            size=size,
            location=location,
            server_id=server_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_protection: Optional[bool] = None,
             id: Optional[int] = None,
             labels: Optional[Mapping[str, Any]] = None,
             linux_device: Optional[str] = None,
             name: Optional[str] = None,
             size: Optional[int] = None,
             location: Optional[str] = None,
             server_id: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if delete_protection is None and 'deleteProtection' in kwargs:
            delete_protection = kwargs['deleteProtection']
        if delete_protection is None:
            raise TypeError("Missing 'delete_protection' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if labels is None:
            raise TypeError("Missing 'labels' argument")
        if linux_device is None and 'linuxDevice' in kwargs:
            linux_device = kwargs['linuxDevice']
        if linux_device is None:
            raise TypeError("Missing 'linux_device' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if server_id is None and 'serverId' in kwargs:
            server_id = kwargs['serverId']

        _setter("delete_protection", delete_protection)
        _setter("id", id)
        _setter("labels", labels)
        _setter("linux_device", linux_device)
        _setter("name", name)
        _setter("size", size)
        if location is not None:
            _setter("location", location)
        if server_id is not None:
            _setter("server_id", server_id)

    @property
    @pulumi.getter(name="deleteProtection")
    def delete_protection(self) -> bool:
        return pulumi.get(self, "delete_protection")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, Any]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="linuxDevice")
    def linux_device(self) -> str:
        return pulumi.get(self, "linux_device")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> Optional[int]:
        return pulumi.get(self, "server_id")


