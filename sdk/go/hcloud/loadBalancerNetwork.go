// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package hcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-hcloud/sdk/go/hcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manage the attachment of a Load Balancer in a Network in the Hetzner Cloud.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-hcloud/sdk/go/hcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			main, err := hcloud.NewLoadBalancer(ctx, "main", &hcloud.LoadBalancerArgs{
//				Name:             pulumi.String("main"),
//				LoadBalancerType: pulumi.String("lb11"),
//				NetworkZone:      pulumi.String("eu-central"),
//			})
//			if err != nil {
//				return err
//			}
//			network, err := hcloud.NewNetwork(ctx, "network", &hcloud.NetworkArgs{
//				Name:    pulumi.String("network"),
//				IpRange: pulumi.String("10.0.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			subnet, err := hcloud.NewNetworkSubnet(ctx, "subnet", &hcloud.NetworkSubnetArgs{
//				NetworkId:   network.ID(),
//				Type:        pulumi.String("cloud"),
//				NetworkZone: pulumi.String("eu-central"),
//				IpRange:     pulumi.String("10.0.1.0/24"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = hcloud.NewLoadBalancerNetwork(ctx, "attachment", &hcloud.LoadBalancerNetworkArgs{
//				LoadBalancerId: main.ID(),
//				SubnetId:       subnet.ID(),
//				Ip:             pulumi.String("10.0.1.5"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// The `pulumi import` command can be used, for example:
//
// ```sh
// $ pulumi import hcloud:index/loadBalancerNetwork:LoadBalancerNetwork example "$LOAD_BALANCER_ID-$NETWORK_ID"
// ```
type LoadBalancerNetwork struct {
	pulumi.CustomResourceState

	// Wether the Load Balancer public interface is enabled. Default is `true`.
	EnablePublicInterface pulumi.BoolOutput `pulumi:"enablePublicInterface"`
	// IP to assign to the Load Balancer.
	Ip pulumi.StringOutput `pulumi:"ip"`
	// ID of the Load Balancer.
	LoadBalancerId pulumi.IntOutput `pulumi:"loadBalancerId"`
	// ID of the Network to attach the Load Balancer to. Using `subnetId` is preferred. Required if `subnetId` is not set. If `subnetId` or `ip` are not set, the Load Balancer will be attached to the last subnet (ordered by `ipRange`).
	NetworkId pulumi.IntOutput `pulumi:"networkId"`
	// ID of the Subnet to attach the Load Balancer to. Required if `networkId` is not set.
	SubnetId pulumi.StringPtrOutput `pulumi:"subnetId"`
}

// NewLoadBalancerNetwork registers a new resource with the given unique name, arguments, and options.
func NewLoadBalancerNetwork(ctx *pulumi.Context,
	name string, args *LoadBalancerNetworkArgs, opts ...pulumi.ResourceOption) (*LoadBalancerNetwork, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LoadBalancerId == nil {
		return nil, errors.New("invalid value for required argument 'LoadBalancerId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LoadBalancerNetwork
	err := ctx.RegisterResource("hcloud:index/loadBalancerNetwork:LoadBalancerNetwork", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLoadBalancerNetwork gets an existing LoadBalancerNetwork resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLoadBalancerNetwork(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LoadBalancerNetworkState, opts ...pulumi.ResourceOption) (*LoadBalancerNetwork, error) {
	var resource LoadBalancerNetwork
	err := ctx.ReadResource("hcloud:index/loadBalancerNetwork:LoadBalancerNetwork", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LoadBalancerNetwork resources.
type loadBalancerNetworkState struct {
	// Wether the Load Balancer public interface is enabled. Default is `true`.
	EnablePublicInterface *bool `pulumi:"enablePublicInterface"`
	// IP to assign to the Load Balancer.
	Ip *string `pulumi:"ip"`
	// ID of the Load Balancer.
	LoadBalancerId *int `pulumi:"loadBalancerId"`
	// ID of the Network to attach the Load Balancer to. Using `subnetId` is preferred. Required if `subnetId` is not set. If `subnetId` or `ip` are not set, the Load Balancer will be attached to the last subnet (ordered by `ipRange`).
	NetworkId *int `pulumi:"networkId"`
	// ID of the Subnet to attach the Load Balancer to. Required if `networkId` is not set.
	SubnetId *string `pulumi:"subnetId"`
}

type LoadBalancerNetworkState struct {
	// Wether the Load Balancer public interface is enabled. Default is `true`.
	EnablePublicInterface pulumi.BoolPtrInput
	// IP to assign to the Load Balancer.
	Ip pulumi.StringPtrInput
	// ID of the Load Balancer.
	LoadBalancerId pulumi.IntPtrInput
	// ID of the Network to attach the Load Balancer to. Using `subnetId` is preferred. Required if `subnetId` is not set. If `subnetId` or `ip` are not set, the Load Balancer will be attached to the last subnet (ordered by `ipRange`).
	NetworkId pulumi.IntPtrInput
	// ID of the Subnet to attach the Load Balancer to. Required if `networkId` is not set.
	SubnetId pulumi.StringPtrInput
}

func (LoadBalancerNetworkState) ElementType() reflect.Type {
	return reflect.TypeOf((*loadBalancerNetworkState)(nil)).Elem()
}

type loadBalancerNetworkArgs struct {
	// Wether the Load Balancer public interface is enabled. Default is `true`.
	EnablePublicInterface *bool `pulumi:"enablePublicInterface"`
	// IP to assign to the Load Balancer.
	Ip *string `pulumi:"ip"`
	// ID of the Load Balancer.
	LoadBalancerId int `pulumi:"loadBalancerId"`
	// ID of the Network to attach the Load Balancer to. Using `subnetId` is preferred. Required if `subnetId` is not set. If `subnetId` or `ip` are not set, the Load Balancer will be attached to the last subnet (ordered by `ipRange`).
	NetworkId *int `pulumi:"networkId"`
	// ID of the Subnet to attach the Load Balancer to. Required if `networkId` is not set.
	SubnetId *string `pulumi:"subnetId"`
}

// The set of arguments for constructing a LoadBalancerNetwork resource.
type LoadBalancerNetworkArgs struct {
	// Wether the Load Balancer public interface is enabled. Default is `true`.
	EnablePublicInterface pulumi.BoolPtrInput
	// IP to assign to the Load Balancer.
	Ip pulumi.StringPtrInput
	// ID of the Load Balancer.
	LoadBalancerId pulumi.IntInput
	// ID of the Network to attach the Load Balancer to. Using `subnetId` is preferred. Required if `subnetId` is not set. If `subnetId` or `ip` are not set, the Load Balancer will be attached to the last subnet (ordered by `ipRange`).
	NetworkId pulumi.IntPtrInput
	// ID of the Subnet to attach the Load Balancer to. Required if `networkId` is not set.
	SubnetId pulumi.StringPtrInput
}

func (LoadBalancerNetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*loadBalancerNetworkArgs)(nil)).Elem()
}

type LoadBalancerNetworkInput interface {
	pulumi.Input

	ToLoadBalancerNetworkOutput() LoadBalancerNetworkOutput
	ToLoadBalancerNetworkOutputWithContext(ctx context.Context) LoadBalancerNetworkOutput
}

func (*LoadBalancerNetwork) ElementType() reflect.Type {
	return reflect.TypeOf((**LoadBalancerNetwork)(nil)).Elem()
}

func (i *LoadBalancerNetwork) ToLoadBalancerNetworkOutput() LoadBalancerNetworkOutput {
	return i.ToLoadBalancerNetworkOutputWithContext(context.Background())
}

func (i *LoadBalancerNetwork) ToLoadBalancerNetworkOutputWithContext(ctx context.Context) LoadBalancerNetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancerNetworkOutput)
}

// LoadBalancerNetworkArrayInput is an input type that accepts LoadBalancerNetworkArray and LoadBalancerNetworkArrayOutput values.
// You can construct a concrete instance of `LoadBalancerNetworkArrayInput` via:
//
//	LoadBalancerNetworkArray{ LoadBalancerNetworkArgs{...} }
type LoadBalancerNetworkArrayInput interface {
	pulumi.Input

	ToLoadBalancerNetworkArrayOutput() LoadBalancerNetworkArrayOutput
	ToLoadBalancerNetworkArrayOutputWithContext(context.Context) LoadBalancerNetworkArrayOutput
}

type LoadBalancerNetworkArray []LoadBalancerNetworkInput

func (LoadBalancerNetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LoadBalancerNetwork)(nil)).Elem()
}

func (i LoadBalancerNetworkArray) ToLoadBalancerNetworkArrayOutput() LoadBalancerNetworkArrayOutput {
	return i.ToLoadBalancerNetworkArrayOutputWithContext(context.Background())
}

func (i LoadBalancerNetworkArray) ToLoadBalancerNetworkArrayOutputWithContext(ctx context.Context) LoadBalancerNetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancerNetworkArrayOutput)
}

// LoadBalancerNetworkMapInput is an input type that accepts LoadBalancerNetworkMap and LoadBalancerNetworkMapOutput values.
// You can construct a concrete instance of `LoadBalancerNetworkMapInput` via:
//
//	LoadBalancerNetworkMap{ "key": LoadBalancerNetworkArgs{...} }
type LoadBalancerNetworkMapInput interface {
	pulumi.Input

	ToLoadBalancerNetworkMapOutput() LoadBalancerNetworkMapOutput
	ToLoadBalancerNetworkMapOutputWithContext(context.Context) LoadBalancerNetworkMapOutput
}

type LoadBalancerNetworkMap map[string]LoadBalancerNetworkInput

func (LoadBalancerNetworkMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LoadBalancerNetwork)(nil)).Elem()
}

func (i LoadBalancerNetworkMap) ToLoadBalancerNetworkMapOutput() LoadBalancerNetworkMapOutput {
	return i.ToLoadBalancerNetworkMapOutputWithContext(context.Background())
}

func (i LoadBalancerNetworkMap) ToLoadBalancerNetworkMapOutputWithContext(ctx context.Context) LoadBalancerNetworkMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancerNetworkMapOutput)
}

type LoadBalancerNetworkOutput struct{ *pulumi.OutputState }

func (LoadBalancerNetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LoadBalancerNetwork)(nil)).Elem()
}

func (o LoadBalancerNetworkOutput) ToLoadBalancerNetworkOutput() LoadBalancerNetworkOutput {
	return o
}

func (o LoadBalancerNetworkOutput) ToLoadBalancerNetworkOutputWithContext(ctx context.Context) LoadBalancerNetworkOutput {
	return o
}

// Wether the Load Balancer public interface is enabled. Default is `true`.
func (o LoadBalancerNetworkOutput) EnablePublicInterface() pulumi.BoolOutput {
	return o.ApplyT(func(v *LoadBalancerNetwork) pulumi.BoolOutput { return v.EnablePublicInterface }).(pulumi.BoolOutput)
}

// IP to assign to the Load Balancer.
func (o LoadBalancerNetworkOutput) Ip() pulumi.StringOutput {
	return o.ApplyT(func(v *LoadBalancerNetwork) pulumi.StringOutput { return v.Ip }).(pulumi.StringOutput)
}

// ID of the Load Balancer.
func (o LoadBalancerNetworkOutput) LoadBalancerId() pulumi.IntOutput {
	return o.ApplyT(func(v *LoadBalancerNetwork) pulumi.IntOutput { return v.LoadBalancerId }).(pulumi.IntOutput)
}

// ID of the Network to attach the Load Balancer to. Using `subnetId` is preferred. Required if `subnetId` is not set. If `subnetId` or `ip` are not set, the Load Balancer will be attached to the last subnet (ordered by `ipRange`).
func (o LoadBalancerNetworkOutput) NetworkId() pulumi.IntOutput {
	return o.ApplyT(func(v *LoadBalancerNetwork) pulumi.IntOutput { return v.NetworkId }).(pulumi.IntOutput)
}

// ID of the Subnet to attach the Load Balancer to. Required if `networkId` is not set.
func (o LoadBalancerNetworkOutput) SubnetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerNetwork) pulumi.StringPtrOutput { return v.SubnetId }).(pulumi.StringPtrOutput)
}

type LoadBalancerNetworkArrayOutput struct{ *pulumi.OutputState }

func (LoadBalancerNetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LoadBalancerNetwork)(nil)).Elem()
}

func (o LoadBalancerNetworkArrayOutput) ToLoadBalancerNetworkArrayOutput() LoadBalancerNetworkArrayOutput {
	return o
}

func (o LoadBalancerNetworkArrayOutput) ToLoadBalancerNetworkArrayOutputWithContext(ctx context.Context) LoadBalancerNetworkArrayOutput {
	return o
}

func (o LoadBalancerNetworkArrayOutput) Index(i pulumi.IntInput) LoadBalancerNetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LoadBalancerNetwork {
		return vs[0].([]*LoadBalancerNetwork)[vs[1].(int)]
	}).(LoadBalancerNetworkOutput)
}

type LoadBalancerNetworkMapOutput struct{ *pulumi.OutputState }

func (LoadBalancerNetworkMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LoadBalancerNetwork)(nil)).Elem()
}

func (o LoadBalancerNetworkMapOutput) ToLoadBalancerNetworkMapOutput() LoadBalancerNetworkMapOutput {
	return o
}

func (o LoadBalancerNetworkMapOutput) ToLoadBalancerNetworkMapOutputWithContext(ctx context.Context) LoadBalancerNetworkMapOutput {
	return o
}

func (o LoadBalancerNetworkMapOutput) MapIndex(k pulumi.StringInput) LoadBalancerNetworkOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LoadBalancerNetwork {
		return vs[0].(map[string]*LoadBalancerNetwork)[vs[1].(string)]
	}).(LoadBalancerNetworkOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LoadBalancerNetworkInput)(nil)).Elem(), &LoadBalancerNetwork{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoadBalancerNetworkArrayInput)(nil)).Elem(), LoadBalancerNetworkArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoadBalancerNetworkMapInput)(nil)).Elem(), LoadBalancerNetworkMap{})
	pulumi.RegisterOutputType(LoadBalancerNetworkOutput{})
	pulumi.RegisterOutputType(LoadBalancerNetworkArrayOutput{})
	pulumi.RegisterOutputType(LoadBalancerNetworkMapOutput{})
}
